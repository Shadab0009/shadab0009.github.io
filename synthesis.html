<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Synthesis: The Soul of Physical Design</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 0;
            background-color: #f4f4f4; /* Light gray background */
            color: #333;
        }
        .container {
            width: 90%;
            max-width: 1000px;
            margin: 20px auto;
            background-color: #ffffff; /* White content area */
            padding: 20px 40px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
            border-radius: 8px;
        }
        h1 {
            color: #0056b3; /* Professional blue title */
            border-bottom: 3px solid #0056b3;
            padding-bottom: 10px;
            margin-top: 0;
        }
        h2 {
            color: #555;
            margin-top: 30px;
            border-bottom: 1px solid #ddd;
            padding-bottom: 5px;
        }
        h3 {
            color: #333;
            margin-top: 20px;
            font-size: 1.2em;
        }
        ul, ol {
            padding-left: 25px;
        }
        .image-placeholder {
            margin: 20px 0;
            padding: 15px;
            border: 1px dashed #ccc;
            background-color: #f9f9f9;
            text-align: center;
            font-style: italic;
            color: #777;
        }
        .note {
            background-color: #e6f7ff;
            border-left: 5px solid #00aaff;
            padding: 15px;
            margin: 20px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Synthesis: The Soul of Physical Design</h1>

        <p>ASIC Physical Design consists of various stages, each with its own critical importance and significance. The quality of each stage directly impacts the subsequent stages. Hence it is really important to ensure the high-quality execution of initial stages to achieve efficient and effective physical design implementation. In this post, we will discuss the detailed significance of **Synthesis**.</p>

        <h2>Synthesis: The Soul of Physical Design</h2>
        <p>Synthesis can be considered as "The Soul" of Physical Design. Synthesis serves as a critical bridge between a high-level design abstract (**RTL**) and Physical design implementation. Below are a few points that make Synthesis the "Heart" of Physical design:</p>
        <ul>
            <li><strong>Translation of RTL into technology-dependent gate-level netlist:</strong> Since ASIC is technology dependent (90nm, 65nm, 28nm...) and RTL (Register Transfer Logic) is technology independent, Synthesis is the first stage where RTL is converted to technology-dependent logic.</li>
            <li><strong>Optimization:</strong> During Synthesis, the design is optimized for key goals such as **Power, Performance, and Area (PPA)**.</li>
            <li><strong>Foundation for Timing Closure:</strong> Synthesis ensures that the design meets target frequency and timing constraints by necessary optimization.</li>
            <li><strong>Hierarchical Design Support:</strong> For larger designs, Synthesis enables Hierarchical Design Methodologies, effective in handling larger, complex ASIC chips.</li>
            <li><strong>Seamless Handoff to Physical Design:</strong> The output of Synthesis, a gate-level netlist, is the key input for Physical Design, ensuring a smooth transition to PNR (Place and Route) and Signoff stages.</li>
        </ul>

        <h2>Logic Synthesis Flow</h2>
        <p>Below is the general logic synthesis flow:</p>

        <div class="image-placeholder">
            [Image Placeholder: Logic Synthesis Flow Diagram (RTL -> Elaborate -> Mapping -> Optimization -> Netlist)]
        </div>

        <h3>Inputs:</h3>
        <ul>
            <li>RTL code</li>
            <li>Timing library (.lib) files</li>
            <li><strong>Design Constraints:</strong>
                <ul>
                    <li>Timing Constraints: Defines the clocking structure and timing requirements.</li>
                    <li>Timing exceptions: Helps to modify/relax any specific path.</li>
                    <li>Area constraints: Guides the tool to optimize Area.</li>
                    <li>Design constraints: Defines physical design rules such as Timing DRV (max_capacitance, max_transition, max_fanout...).</li>
                    <li>Power Constraints: Guides the tool to optimize Power.</li>
                </ul>
            </li>
            <li>UPF (only for low power design)</li>
        </ul>

        <h3>Elaborate:</h3>
        <ul>
            <li>During elaboration, the Synthesis tool converts sequential/combinational elements based on the high-level information of the RTL syntax.
                <ul>
                    <li><code>posedge/negedge</code> --> infers the flip-flops.</li>
                    <li><code>If.....else</code> --> Multiplexers (if any missing condition, a Latch is inferred along with Mux).</li>
                    <li><code>Case statements</code> --> encoders.</li>
                </ul>
            </li>
            <li>Performs high-level optimization such as removing combinational loops, floating inputs, etc.</li>
        </ul>

        <h3>Sanity checks:</h3>
        <p>Before proceeding to further stages, it is really important to check the quality of inputs.</p>
        <p class="note">For more information about sanity checks, refer to the related content on Floorplan Essential Sanity Checks.</p>

        <h3>Mapping:</h3>
        <p>This is the stage where RTL is converted to gate-level representation. Mapping is done in two stages:</p>
        <ol>
            <li><strong>Generic Mapping:</strong> Cells are mapped to a generic library which is independent of the technology library.</li>
            <li><strong>Technology Mapping:</strong> The tool converts generic gate-level representation to technology-dependent based on provided timing libraries.</li>
        </ol>

        <h3>Optimization:</h3>
        <p>This is the main step where the design is optimized based on given constraints of Power, Performance, and Area (PPA).</p>
        <ul>
            <li><strong>Logic optimization</strong> is done considering power, performance, and area (e.g., restructuring <code>Y = AB + AC</code> into <code>Y = A(B+C)</code>).</li>
            <li><strong>Timing optimization</strong> is done based on given timing constraints such as clock information and timing exceptions.</li>
        </ul>

        <h2>Advanced Optimization Techniques</h2>
        <p>Below are a few Advanced Optimization Techniques used to achieve better PPA (Power, Performance, Area):</p>
        
        <h3>Sequential/Combinational Merging</h3>
        <ul>
            <li><strong>Combinational Merging:</strong> Merging multiple individual combinational cells into a single, more efficient logic structure without affecting functionality.</li>
            <li><strong>Sequential Merging/Multi-Bit Flip-Flops:</strong> Combining multiple single-bit flops into a single multi-bit flop to reduce power, area, and clock tree complexity.
                <div class="image-placeholder">
                    [Image Placeholder: Diagram illustrating the merging of two single-bit flops into one multi-bit flop]
                </div>
            </li>
        </ul>
        
        <h3>Retiming</h3>
        <p>Adjusting the position of flip-flops along the data-path without affecting the functionality to reduce the delay of critical logic and allow for higher operating frequency. This is limited to paths having the same clock domain.</p>
        <div class="image-placeholder">
            [Image Placeholder: Diagram showing retiming to balance critical path delays]
        </div>

        <h3>Ungrouping/Boundary Merging</h3>
        <p>Flattening or ungrouping small modules to reduce the overall data-path delay when module boundaries are not strictly restricted.</p>

        <h3>Sequential Removal</h3>
        <p>Removing registers not required for design functionality to reduce area and power.</p>
        <ul>
            <li>**Unloaded registers:** Flops with floating outputs.</li>
            <li>**Constant registers:** Flops with data input pins tied high or low.</li>
        </ul>

        <h3>Boundary Optimization</h3>
        <p>Techniques to optimize across the hierarchical interfaces of the design:</p>
        <ul>
            <li><strong>Constant Propagations:</strong> Removing gates whose function is fixed by a constant boundary input (e.g., removing an AND gate if one input is tied to '0').</li>
            <li><strong>Phase Inversion:</strong> Merging and removing pairs of inverters across a boundary.</li>
            <li><strong>Unload Propagation:</strong> Removing unloaded logic across boundaries.</li>
            <li>**Assign statements:** When enabled, this optimization removes unnecessary buffers that are otherwise added to fix assign statements in empty modules.</li>
        </ul>

        <h3>DFT Insertion</h3>
        <p>Inserting Design For Testability (DFT) logic related to testing and scan-chains.</p>
        
        <h3>Incremental Optimization</h3>
        <p>Optimization performed after DFT insertion to achieve final PPA requirements.</p>

        <h3>Output</h3>
        <p>The final output is the **Gate-level Netlist** along with quality reports.</p>

        <h2>Physical Synthesis</h2>
        <p>Physical Synthesis follows the same flow as Logical Synthesis but requires additional physical inputs, including Floorplan information, Technology files (.tf), Physical library (.lef), and RC coefficient file (.tluplus).</p>
        
    </div>
</body>
</html>
